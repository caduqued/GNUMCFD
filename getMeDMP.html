<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <title>Simulacion de flujos viscoelasticos usando Discrete MultiPhysics</title>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="stylesheet" href="assets/css/main.css" />
  <link rel="stylesheet" href="assets/css/tablesaw.css">
  <link rel="stylesheet" href="assets/css/getMeDMP.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body class="subpage">

	<!-- Header -->
    <header id="header">
    	<div class="logoun">
    		<span>GNUM-CFD @ UN  <p style="color:coral; display: inline-block;font-weight:400">< What we do > </p><span> 
		</div>
		<a href="#menu">Menu</a>
	</header>

	<!-- Nav -->
		<nav id="menu">
			<ul class="links">
    			<li><a href="index.html">Home</a></li>
				<li><a href="people.html">Who we are</a></li>
				<li><a href="portfolio.html">Showcase</a></li>
				<li><a href="cluster.html">Aurora</a></li>
				<li><a href="getMeDMP.html">GetMe DMP!</a></li>
			</ul>
		</nav>

	<!-- One -->
		<section id="One" class="wrapper style3">
			<div class="inner">
				<header class="align-center">
					<p>Get to know about using Discrete Multiphysics</p>
					<h2>Projects Showcase</h2>
				</header>
			</div>
		</section>

<!-- Main -->
<section id="getMeDMP" class="getMeDMP">
    <div class="getMeDMP">

<h1 class="title">Simulacion de flujos viscoelasticos con DMP</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#sec:estructuraLammps"
id="toc-sec:estructuraLammps">Estructura de código en LAMMPS</a>
<ul>
<li><a href="#herencia" id="toc-herencia">Herencia</a></li>
<li><a href="#función-virtual" id="toc-función-virtual">Función
virtual</a></li>
<li><a href="#herencia-y-sintaxis-de-clases-en-lammps"
id="toc-herencia-y-sintaxis-de-clases-en-lammps">Herencia y sintaxis de
clases en LAMMPS</a></li>
<li><a href="#método-constructor" id="toc-método-constructor">Método
constructor</a></li>
<li><a href="#método-destructor" id="toc-método-destructor">Método
destructor</a></li>
<li><a href="#método" id="toc-método">Método </a></li>
<li><a href="#método-1" id="toc-método-1">Método </a></li>
<li><a href="#método-2" id="toc-método-2">Método </a></li>
<li><a href="#métodos-y" id="toc-métodos-y">Métodos , y </a></li>
</ul></li>
<li><a href="#implementación-directa-vs-enfoque-dmp"
id="toc-implementación-directa-vs-enfoque-dmp">Implementación directa vs
enfoque DMP</a>
<ul>
<li><a
href="#simulación-mediante-implementación-directa---modelo-kelvin"
id="toc-simulación-mediante-implementación-directa---modelo-kelvin">Simulación
mediante implementación directa - Modelo Kelvin</a></li>
<li><a href="#simulación-mediante-enfoque-dmp"
id="toc-simulación-mediante-enfoque-dmp">Simulación mediante enfoque
DMP</a></li>
</ul></li>
</ul>
</nav>
<h1 id="sec:estructuraLammps">Estructura de código en LAMMPS</h1>
<p>Tras las versiones iniciales en <code>Fortran77</code> y
<code>Fortran90</code>, LAMMPS está ahora escrito en <code>C++</code>,
un lenguaje orientado a objetos que permite a cualquier programador
explotar el paradigma de programación de clases. La declaración de una
clase, incluida la firma de las variables de la instancia y las
funciones (o métodos), puede accederse y ser utilizada mediante la
creación de una instancia de esa clase. Los datos y funciones de una
clase se denominan miembros de la clase. La definición (o
implementación) de una función miembro puede darse dentro o fuera de la
definición de la clase. Una clase tiene secciones de tipo
<code>privado</code>, <code>publico</code> y <code>protegido</code> que
contienen los correspondientes miembros de la clase.</p>
<ul>
<li><p>A los miembros privados, definidos antes de la palabra clave
public, no se puede acceder desde fuera de la clase. Sólo se puede
acceder a ellos mediante funciones de la clase o “amigas", que se
declaran como con acceso a los miembros de la clase, sin ser ellas
mismas miembros. Todos los miembros de la clase son privados por
defecto.</p></li>
<li><p>A los miembros públicos se puede acceder desde fuera de la clase
en cualquier lugar dentro del ámbito del objeto de la clase.</p></li>
<li><p>Los miembros protegidos son similares a los miembros privados,
pero pueden ser accedidos por clases derivadas o clases hijas, mientras
que los miembros privados no pueden ser accedidos de esta
forma.</p></li>
</ul>
<h2 id="herencia">Herencia</h2>
<p>Un concepto importante en la programación orientada a objetos es el
de herencia. La herencia permite definir una clase en términos de otra
clase y la nueva clase hereda los miembros de la clase existente. Esta
clase existente se denomina clase base (o padre), y la nueva clase se
denomina subclase, clase hija o clase derivada. La idea de herencia
implementa una relación de tipo “es un”. Por ejemplo, un Mamífero ES-UN
Animal, un Perro ES-UN Mamífero y, por tanto, un Perro ES-UN Animal
también.</p>
<p>El tipo de herencia se especifica mediante el especificador de
acceso, que puede ser público, protegido o privado. Si no se utiliza el
especificador de acceso, entonces es privada por defecto, pero la
herencia pública se utiliza comúnmente: los miembros públicos de la
clase base se convierten en miembros públicos de la clase derivada y los
miembros protegidos de la clase base se convierten en miembros
protegidos de la clase derivada. Los miembros privados de una clase base
nunca son accesibles directamente desde una clase derivada, pero se
puede acceder a ellos a través de llamadas a los miembros públicos y
protegidos de la clase base.</p>
<p>La relación de herencia entre las clases base y derivada se declara
en la clase derivada mediante la siguiente sintaxis:</p>
<div class="sourceCode" id="cb1" data-language="C++"
data-caption="Definición de clase en \texttt{C++} mediante
    herencia entre clases"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> nombre_clase_derivada<span class="op">:</span>  access_specifier nombre_clase_base</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">/* ... */</span><span class="op">};</span></span></code></pre></div>
<h2 id="función-virtual">Función virtual</h2>
<p>La firma de una función <span class="math inline">\(f\)</span> debe
declararse con la palabra clave en una clase base para permitir su
definición (implementación), o redefinición, en una clase derivada .
Entonces, cuando un objeto de la clase derivada se utiliza como elemento
de la clase base , y se llama a <span class="math inline">\(f\)</span>,
se ejecuta la implementación de la función de la clase derivada. No hay
nada malo en poner el delante de las funciones dentro de las clases
derivadas, pero no es necesario, a menos que se sepa con seguridad que
la clase no tendrá ningún hijo que necesite anular las funciones de la
clase base. Una clase que declara o hereda una función virtual se
denomina clase polimórfica.</p>
<h2 id="herencia-y-sintaxis-de-clases-en-lammps">Herencia y sintaxis de
clases en LAMMPS</h2>
<p>Una representación esquemática del árbol de herencia de LAMMPS se
muestra en la (tomada de <span class="citation"
data-cites="Albano2021"></span>): LAMMPS es la clase de nivel superior
para todo el código, luego todas las clases núcleo, resaltadas en azul
en la figura, heredan todos los constructores, destructores, miembros
operadores de asignación, amigos y miembros privados declarados y
definidos en LAMMPS. Las clases núcleo realizan acciones fundamentales
de LAMMPS. Por ejemplo, la clase recoge y almacena todos los datos por
átomo, o por partícula, mientras que la clase construye las listas de
vecinos <span class="citation"
data-cites="lammpsSite lammpsWeb"></span>.</p>
<figure>
<img src="./imagenes/inheritanceTreeLAMMPS.png" id="fig:inheritanceTree"
style="width:60.0%" alt="Ejemplo de un arbol de herencia en LAMMPS" />
<figcaption aria-hidden="true">Ejemplo de un arbol de herencia en
LAMMPS</figcaption>
</figure>
<p>Las clases de estilo, resaltadas en rojo en la , heredan todos los
constructores, destructores, miembros operadores de asignación, amigos y
miembros privados declarados y definidos en LAMMPS y en la clase núcleo
correspondiente. Las clases de estilo son también clases virtuales
padres de muchas clases hijas que implementan la interfaz definida por
la clase padre. Por ejemplo, el estilo tiene alrededor de 100 clases
hijas. Cada estilo se compone de un par de archivos, como se indica a
continuación:</p>
<dl>
<dt>namestyle.h</dt>
<dd>
<p>La cabecera del estilo, donde se define el estilo de la clase y se
declaran todos los objetos, métodos y constructores.</p>
</dd>
<dt>namestyle.cpp</dt>
<dd>
<p>Donde se definen todos los objetos, métodos y constructores
declarados en la clase de estilo.</p>
</dd>
</dl>
<p>Cuando se escribe un nuevo estilo, deben crearse los archivos y .
Cada estilo de "familia" tiene su propio conjunto de métodos, declarados
en la cabecera y definidos en el archivo , para definir el ámbito del
estilo. Por ejemplo, el estilo par son clases que establecen la(s)
fórmula(s) que LAMMPS utiliza para calcular las interacciones entre
pares, mientras que el estilo enlace establece la(s) fórmula(s) para
calcular las interacciones de enlace entre pares de átomos <span
class="citation" data-cites="lammpsSite lammpsWeb"></span>. Cada estilo
de par tiene algunas funciones recurrentes como , y . Aunque el ámbito
final de esas funciones puede diferir para diferentes estilos, todas
comparten un papel similar dentro de las clases. Un ejemplo de un
encabezado de estilo de par en LAMMPS se muestra a continuación para el
estilo .</p>
<p>Dado que la versión actual de LAMMPS está completamente basada en ,
todos los miembros de la clase están definidos en un archivo . Con el
fin de ampliar la presente discusión, y tomando como referencia el
estilo del par , cada método declarado en será detallatado y comentado a
continuación. Aunque estos métodos son específicos de cada estilo, el
objetivo es dar una visión general de cómo se definen los métodos en el
archivo en LAMMPS. En cualquier caso, la metodología para definir
estilos en LAMMPS puede ser aplicada a la generación de otros estilos
que cualquier programador desee implementar.</p>
<h2 id="método-constructor">Método constructor</h2>
<p>Cualquier clase suele incluir una función miembro llamada
constructor. El constructor se invoca mecánicamente cuando se crea un
objeto de la clase. Esto permite a la clase inicializar miembros o
asignar almacenamiento. A diferencia de los demás miembros de la clase,
el nombre del constructor debe coincidir con el nombre de la clase y no
tiene tipo de retorno, como se muestra en .</p>
<pre><code>[
    language=C++,
    caption={Ejemplo de definición de m\&#39;etodo constructor},
    label={lst:constructorExample}]
/* ----------------------------------------------------------------- */
PairSPHTaitwater::PairSPHTaitwater(LAMMPS *lmp) : Pair(lmp)
{
  restartinfo = 0;
  first = 1;
}
/* ----------------------------------------------------------------- */</code></pre>
<h2 id="método-destructor">Método destructor</h2>
<p>El papel del método destructor es desasignar la memoria dinámica
asignada, siendo invocados mecánicamente justo antes del final del
tiempo de vida de la clase. De forma similar a los constructores, los
destructores no tienen un tipo de retorno y tienen el mismo nombre que
el nombre de la clase pero con el simbolo tilde (<span
class="math inline">\(\sim\)</span>) antepuesto, como se muestra a
continuación.</p>
<pre><code>[
    language=C++,
    caption={Ejemplo de definición de m\&#39;etodo destructor},
    label={lst:destructorExample}]
/* ----------------------------------------------------------------- */
PairSPHTaitwater::~PairSPHTaitwater() {
  if (allocated) {
    memory-&gt;destroy(setflag);
    memory-&gt;destroy(cutsq);
    memory-&gt;destroy(cut);
    memory-&gt;destroy(rho0);
    memory-&gt;destroy(soundspeed);
    memory-&gt;destroy(B);
    memory-&gt;destroy(viscosity);
  }
}
/* ----------------------------------------------------------------- */</code></pre>
<h2 id="método">Método </h2>
<p>El método es un miembro virtual del estilo de par y es una de las
funciones más relevantes en un número de clases en LAMMPS. Por ejemplo,
en las clases de estilos de pares se utiliza para calcular la
interacción entre pares del estilo de par específico. Esto puede verse
en el Listado 5 comentado, donde la fuerza aplicada en un par de
partículas vecinas es derivada usando la ecuación de Tait, líneas
131-151. En compute todos los parámetros locales necesarios para
calcular la interacción entre pares son declarados y definidos dentro
del método.</p>
<h2 id="método-1">Método </h2>
<p>es una función pública de tipo que lee el script de entrada
comprobando que todos los argumentos del estilo par están declarados. Si
los argumentos están presentes, los almacena para que puedan ser
utilizados por . A continuación se muestran ejemplos de secuencias de
comandos de entrada de estilo par sin argumentos y de estilo par con
argumentos con las configuraciones correspondientes:</p>
<p><strong>Estilo de par sin argumentos:</strong> . Como se describe en
el manual de SPH para LAMMPS <span class="citation"
data-cites="lammpsSPH"></span>, la línea de comandos para invocar el
estilo de par es:</p>
<p>la cual se usa en los scripts de configuración de caso de LAMMPS. En
este estilo de par sólo hay una palabra que define el estilo de par
(“sph/taitwater"), sin argumentos. Por esta razón en el método de este
par, mostrado en el , produce un error cuando la sentencia es verdadera,
es decir si el número de argumentos distinto de cero.</p>
<p><span>lst:settingsWithOutArgs</span><span>settingsPairSphTaitwater.cpp</span></p>
<p><strong>Estilo de par con argumentos:</strong> . Como se describe en
el manual de SPH para LAMMPS <span class="citation"
data-cites="lammpsSPH"></span>, la línea de comandos para invocar el
estilo de par , que si requiere argumentos es:</p>
<p>y la cual, como en el caso anterior, debe ser usada en los scripts de
configuración de caso de LAMMPS. En este estilo de par la cadena de
caracteres que define el estilo de par es “sph/rhosum", más un argumento
denominado . Por esta razón en el archivo , presentado en el , cuando la
sentencia es verdadera (número de argumentos distinto de uno) se produce
un error. Cuando la sentencia if es falsa el método asigna el valor de a
la variable , utilizando la función definida en la clase .</p>
<p><span>lst:settingsWithArgs</span><span>settingsPairSphRhoSum.cpp</span></p>
<h2 id="método-2">Método </h2>
<p>Similar a , el método es una función pública de tipo que lee y
establece los coeficientes utilizados por el método de cada estilo de
par. Para cada par <span class="math inline">\(ij\)</span> es posible
establecer diferentes coeficientes. Los coeficientes se suministran a
través del archivo de entrada de caso de simulación LAMMPS con una línea
de comando iniciando con la instrucción . Por ejemplo, para invocar y
emplear el estilo de par , se debe agregar la siguiente línea en el
arcivo de configuración de caso:</p>
<p>con la cuál se definen los parámetros para configurar el estilo de
par . Para este estilo de par deben suministrase en total seis
argumentos. Como puede verse en el , cuando la sentencia es verdadera
(número de argumentos distinto de seis) se produce un error. Cuando la
sentencia es falsa asigna el tipo de partículas <span
class="math inline">\(I\)</span> y <span
class="math inline">\(J\)</span>, y adicionalmente el valor de las
variables , , y mediante la función definida en la clase . En este
ejemplo el método también asigna las variables para cada partícula, lo
que puede verse en el bucle doble mostrado entre las líneas 19 a la 35
del .</p>
<p><span>lst:coeffTaitwater</span><span>coeffPairSphTaitwater.cpp</span></p>
<p>Un segundo ejemplo del método es el del estilo de par , que se
presenta en el . La sintaxis requerida para invocar este estilo de par
en una simulación LAMMPS es mediante la siguiente línea de código:</p>
<p>en donde puede verse que este estilo de par requiere tres argumentos.
Examinando la definición del método para este estilo de par (), es claro
que cuando la sentencia es verdadera (número de argumentos distinto de
tres) se produce un error. Cuando no se produce el error la función
asigna el tipo de partículas <span class="math inline">\(I\)</span> y
<span class="math inline">\(J\)</span> además del valor de <span
class="math inline">\(h\)</span> a la variable i, mediante el uso de las
funciones y definidas en la clase . Por último, dentro del bucle doble ,
definido entre las líneas 14 a la 20 del , se asignan las variables para
cada partícula.</p>
<p><span>lst:coeffSphRhoSum</span><span>coeffPairSphRhoSum.cpp</span></p>
<h2 id="métodos-y">Métodos , y </h2>
<p>Otros métodos comunmente encontrados en la definición de las clases
de estilo de par son , , y . comprueba si se han asignado todos los
coeficientes de un par <span class="math inline">\(i\,j\)</span> dado.
Si se han asignado, el método garantiza la simetría de la matriz, como
se muestra en . Por otro lado, en , mostrado en el , se evalúan la
fuerza y la energía de una única interacción de pares, o de un único
enlace o ángulo (en caso de estilo enlace o ángulo), entre dos átomos.
El método es invocado específicamente por la línea de comando (o ) para
calcular propiedades de interacciones individuales de pares o enlaces
<span class="citation" data-cites="lammpsSite"></span>. Finalmente, el
método , mostrado en , es una función protegida que asigna memoria
dinámica. La asignación de memoria dinámica se utiliza cuando la
cantidad de memoria necesaria depende de la entrada del usuario. Como se
ha explicado antes, al final del tiempo de vida de la clase, los
destructores desasignarán la memoria utilizada por .</p>
<p><span>lst:initOneSphTaitwater</span><span>initOnePairSphTaitwater.cpp</span></p>
<p><span>lst:singleSphTaitwater</span><span>singlePairSphTaitwater.cpp</span></p>
<p><span>lst:allocateSphTaitwater</span><span>allocatePairSphTaitwater.cpp</span></p>
<h1 id="implementación-directa-vs-enfoque-dmp">Implementación directa vs
enfoque DMP</h1>
<p>La principal diferencia entre el enfoque de implementación directa
vs. el enfoque de Multifísica discreta (DMP) radica en la complejidad
del primer enfoque en contraste con la simplicidad de adaptación del
enfoque DMP. En el primer caso, el de implementación de estilo de par
directamente en LAMMPS, hay que generar toda una nueva clase que deberá
ajustarse a algún modelo de comportamiento de fluido viscoelástico, por
ejemplo mediante la selección de uno de los modelos estándar presentados
en <a href="#sec:fundamentosViscoElasticidad" data-reference-type="ref"
data-reference="sec:fundamentosViscoElasticidad">[sec:fundamentosViscoElasticidad]</a>,
y la genereación de una nueva clase de estilo de par. Este proceso
conlleva redefinir todos los métodos requeridos por el nuevo estilo de
par y, por tanto, resultar en un trabajo que puede ser bastante
intensivo o dispendioso. Por otro lado, mediante el enfoque DMP basta
con hacer una selección cuidadosa de los estilos de par a ser utilizados
de manera concurrente, y generar una adecuada definición de caso en el
script de caso de LAMMPS. En cualquier caso, independiente del enfoque
de simulación empleado, es necesario llevar a cabo un proceso de
selección de los parámetros de simulación de los pares de estilo
seleccionados para llevara a cabo la simulación de flujo viscoelástico.
A continuación se presentan algunos detalles específicos del tratamiento
que debe hacerse en cada uno de estos enfoques.</p>
<h2
id="simulación-mediante-implementación-directa---modelo-kelvin">Simulación
mediante implementación directa - Modelo Kelvin</h2>
<p>Como caso de contexto de implementación de un modelo clásico
viscoelástico se presentaran algunos detalles de la implementación
directa del modelo de Kelvin. Para este fin se usaran los conceptos
mostrados en la sección anterior (<a href="#sec:estructuraLammps"
data-reference-type="ref" data-reference="sec:estructuraLammps">1</a>)
para generar un nuevo potencial de enlace disipativo que puede
utilizarse para modelar sustancias viscoelásticos. Como se había
indicado anteriormente, el modelo de Kelvin se usa para la modelación de
materiales viscoelásticos mediante la suposición de un comportamiento
equivalente al de un arreglo en paralelo de un componente tipo
amortiguador puramente viscoso y de un componente tipo resorte puramente
elástico conectados en paralelo, como se muestra en la .</p>
<figure>
<img src="./imagenes/kelvinModel.png" id="fig:kelvinModelV2"
style="width:25.0%"
alt="Representación esquemática del Modelo estándar de Kelvin." />
<figcaption aria-hidden="true">Representación esquemática del Modelo
estándar de Kelvin.</figcaption>
</figure>
<p>Como se indicaba anteriormente, este arreglo de elementos disipativos
y elasticos puede expresarse como: <span
class="math display">\[\label{eq:modeloKelvinV2}
    \sigma(t) = k \epsilon(t) + \eta \dot{\epsilon}\]</span> donde el
esfuerzo queda expresado como función de la deformación <span
class="math inline">\(\epsilon\)</span>, la rata de deformanción <span
class="math inline">\(\dot{\epsilon}\)</span>, y dos parámetros <span
class="math inline">\(k\)</span> y <span
class="math inline">\(\eta\)</span>, representando la constante elástica
y la constante disipativa viscosa, respectivamente.</p>
<p>Para llevar a cabo la implementación de un estilo de par, o de
cualquier otra clase de hecho, es conveniente tomar como punto de
partida una clase similar o asociada ya existente. Esta práctica es
común en muchas aplicaciones de programación cientifica, con otro
ejemplo extendido de esta práctica la programación de funciones o
solucionadores personalizados usados en el programa , por mencionar un
caso adicional. Para la implementación de este estilo de par
personalizado se ha seleccionado como referencia la clase del estilo de
par denominado , cuya estructura de implementación se presenta en ,
mostrado a continuación:</p>
<p><span>lst:bondHarmonicCpp</span><span>bondHarmonic.cpp</span></p>
<p>Como es costumbre, la nueva clase debe declararse e inicializarse
mediante los archivos de encabezado, , y de código los que, en general,
deberán guardarse en el directorio <em>/src/MOLECULE</em> de la carpeta
de instalación de LAMMPS, y siguiendo una jerarquia como la mostrada en
.</p>
<figure>
<img src="./imagenes/newKelvinBondHierarchy.png" id="fig:jerarquia"
style="width:85.0%"
alt="Jerarquia para la definición de un estilo de par personalizado tipo Kelvin." />
<figcaption aria-hidden="true">Jerarquia para la definición de un estilo
de par personalizado tipo Kelvin.</figcaption>
</figure>
<p>Todas las funciones serán las mismas que en el estilo de referencia.
Sin embargo, en el nuevo estilo , tenemos que sustituir el texto
“BondHarmonic" por un nuevo texto “BondKelvin", como puede verse en
.</p>
<p><span>lst:bondKelvinCpp</span><span>bondKelvin.cpp</span></p>
<p>En comparación con el enlace de tipo armónico ahora se requiere de un
nuevo parámetro, <span class="math inline">\(\eta\)</span> o , desde el
archivo de entrada. Por esta razón necesitamos modificar los métodos , ,
, , y .</p>
<p>Siguiendo el orden de inicialización de funciones (ver ), a
continuación se muestran los códigos abreviados de estos métodos, en el
orden presentado, para el estilo original y los códigos abreviados para
el nuevo estilo .</p>
<p><span>lst:destructorBondHarmonicCpp</span><span>destructorBondHarmonic.cpp</span></p>
<p><span>lst:destructorBondKelvinCpp</span><span>destructorBondKelvin.cpp</span></p>
<p>El siguiente método a generar, siguiendo el orden presentado en , es
. En el nuevo estilo de par se requiere la rata de deformación, <span
class="math inline">\(\dot{\epsilon}\)</span>, que puede también
considerarse como la velocidad de deformación. Para poder utilizar dicha
variable dentro del nuevo estilo de pares necesitamos declarar e
inicializar las velocidades de cada partícula, lo que constituye la
modificación a ser hecha, en comparación con el estilo de par
ármonico.</p>
<p><span>lst:computeBondHarmonicCpp</span><span>computeBondHarmonic.cpp</span></p>
<p><span>lst:computeBondKelvinCpp</span><span>computeBondKelvin.cpp</span></p>
<p>Dentro del bucle del método original, es necesario añadir un nuevo
conjunto de líneas de código para calcular la fuerza del componente
viscoso, así como las variaciones de energía. Este cáculo, que no se
presenta en detalle, requiere de la estimación de velocidades de
partícula y direcciones para cálculo de fuerzas del componente viscoso.
Estas definiciones de variables se presentan en .</p>
<p><span>lst:computeVelsAndDirsBondKelvinCpp</span><span>computeVelsAndDirsBondKelvin.cpp</span></p>
<p>de manera que ahora es posible escribir las expresiones modificadas
para el cálculo de la fuerza aplicada a cada par de partículas, como se
presenta a continuación. Como en los caoss anteriores se presenta el
código resumido para el estilo de par de referencia () y para el nuevo
estilo de par ().</p>
<p><span>lst:computeForcesBondHarmonicCpp</span><span>computeForcesBondHarmonic.cpp</span></p>
<p><span>lst:computeForcesBondKelvinCpp</span><span>computeForcesBondKelvin.cpp</span></p>
<p>Siguiendo la línea de trabajo anterior, y dado que fue necesario
introducir un nuevo parámetro en el estilo de par, es necesario
modificar el método para considerar la necesidad de reserva de nueva
memoria dinámica, lo que se presenta a continuación.</p>
<p><span>lst:allocateBondHarmonicCpp</span><span>allocateBondHarmonic.cpp</span></p>
<p><span>lst:allocateBondKelvinCpp</span><span>allocateBondKelvin.cpp</span></p>
<p>El coeficiente del componente de disipación viscosa <span
class="math inline">\(\eta\)</span> (o el análogo a un elemento
amortiguador), debe ser suministrado por el usuario mediante línea de
código en el archivo de configuración de caso de LAMMPS, por lo que es
necesario también hacer ajustes enla definición del método , que se
presenta en .</p>
<p><span>lst:coeffBondHarmonicCpp</span><span>coeffBondHarmonic.cpp</span></p>
<p><span>lst:coeffBondKelvinCpp</span><span>coeffBondKelvin.cpp</span></p>
<p>El estilo de par de referencia tiene también las funciones y que
tienen que ser modificadas. Estas funciones de tipo escriben y leen un
archivo de geometría que puede utilizarse como archivo de soporte en el
archivo de entrada o de configuración de caso LAMMPS. El código de
referencia y su respectiva modificación para estos métodos se presentan
en</p>
<p>En el archivo encabezado del nuevo estilo de par se debe sustituir el
texto “BondHarmonic" por un nuevo texto “BondKelvin", así como declarar
un nuevo miembro protegido en la clase, el puntero a .</p>
<p><span>lst:bondHarmonicH</span><span>bondHarmonic.h</span></p>
<p><span>lst:bondKelvinH</span><span>bondKelvin.h</span></p>
<p>Finalmente, dado que el nuevo estilo debe invocarse desde el script
de configuración de caso de LAMMPS, y ya que el nuevo estilo de par está
completamente programado, es necesario compilarlo y luego invocarlo
escribiendo las siguientes líneas de comando en el script de
configuración de caso:</p>
<h2 id="simulación-mediante-enfoque-dmp">Simulación mediante enfoque
DMP</h2>
<p>Mientras que la simulación de flujos viscoelásticos con
implementación directa requirió la creación y ajuste de toda una nueva
clase de estilo de par, con todo lo que implicó, el enfoque DMP se basa
en llevar a cabo la simulación del flujo mediante acople de potenciales
simples ya existentes, pero que emulen los componentes elástico y
viscoso requeridos. En general, como se expondrá a continuación, se
desea llevara a cabo una simple superposición aditiva de potenciales, de
manera que el efecto final resultante será precisamente el de una
sustancia con comportamiento elástico y viscoso simultaneamente.</p>
<p>Como se ha indicado en forma general, la viscoelasticidad puede
implementarse directamente en SPH (por ejemplo, <span class="citation"
data-cites="Ellero2002"></span>). Sin embargo, de manera equivalente a
la implementación directa de modelos convencionales de viscoelasticidad,
esto implica reescribir la ecuación de movimiento para tener en cuenta
un modelo específico de viscoelasticidad. En el caso de un código de
partículas como LAMMPS, por ejemplo, esto implicaría reescribir grandes
secciones del código dedicadas a SPH cada vez que introduzcamos un nuevo
modelo de viscoelasticidad. El enfoque propuesto en este estudio modela
la viscoelasticidad mediante la combinación de diferentes potenciales de
partículas, que es un procedimiento estándar en los códigos de
partículas, en lugar de reescribir las ecuaciones de movimiento. Para la
parte viscosa, se adopta el enfoque SPH estándar descrito en . De forma
análoga a la idea en la que se basan los modelos viscoelásticos básicos
más utilizados anteriormente, se propone una técnica de modelación
alternativa dentro de un marco basado en partículas, en el que los
potenciales entre partículas que abordan las interacciones viscosas y
elásticas por separado se mezclan de forma aditiva para imitar la
respuesta dual disipativa y restauradora de las sustancias
viscoelásticas. Con este fin, el soporte viscoso SPH se mezcla con un
potencial que se asemeja a un comportamiento elástico restaurador, con
el objetivo de obtener la respuesta dual característica de las
sustancias viscoelásticas. En nuestro planteamiento, las propiedades
viscosas vienen dadas al fluido por las ecuaciones SPH . Además, en
principio, se busca utilizar potenciales equivalente a los resortes
armónicos que se emplean en el Lattice Spring Model (LSM) para añadir
elasticidad al material (véase <span class="citation"
data-cites="Pazdniakou2012"></span>),</p>
<p><span class="math display">\[\label{eq:modelLSM}
   U_{\textrm{LSM}}(r) = \dfrac{1}{2} k (r-r_0)^2\]</span></p>
<p>que proporcionaría una fuerza <span
class="math inline">\(F(r)=-\nabla U(r) = -k(r-r_0)\)</span> entre dos
partículas conectadas por el resorte con una rigidez <span
class="math inline">\(k\)</span>, separadas una distancia <span
class="math inline">\(r\)</span>, y con una distancia de equilibrio
<span class="math inline">\(r_0\)</span>. La combinación demodelo SPH y
el modelo tipo LSM conferirá propiedades viscoelásticas al material. En
<span class="citation" data-cites="Sahputra2020"></span> se empleó un
enfoque similar para la modelación de sólidos viscoelásticos. Sin
embargo, los fluidos no pueden modelarse del mismo modo porque los
resortes limitan las partículas, que no pueden fluir como debería
ocurrir en los fluidos. La solución que se propone en el presente
trabajo es emplear una mezcla de dos potenciales para imitar
parcialmente el LSM, pero con la ventaja de tener una distancia de
desactivación o de corte a partir de la cual el potencial compuesto deja
de actuar, permitiendo que las partículas fluyan libremente. Se eligió
un potencial exclusivamente atractivo, propuesto por primera vez por
<span class="citation" data-cites="PhysRevE.72.011506"></span>, para
proporcionar la parte atractiva del análogo del LSM, y definido
como,</p>
<p><span class="math display">\[\label{eq:cosineSquaredDefinition}
U_{\textrm{CS}}(r) = \left\{
        \begin{array}{lll}
            -\epsCosSq &amp; \quad r &lt; \sigma \\
            -\epsCosSq
\cos{\left(\dfrac{\pi(r-\sigma)}{2(\rcCosSq-\sigma)}\right)}^{2} &amp;
                        \quad \sigma \leq r &lt; \rcCosSq \\
            0 &amp;  \quad r \geq \rcCosSq
        \end{array}
    \right.\]</span></p>
<p>que, como se ilustra esquemáticamente en la , es un valor constante
de por debajo de una distancia interparticular <span
class="math inline">\(\sigma\)</span>, que aumenta proporcionalmente a
<span class="math inline">\(r\)</span> hasta que desaparece por encima
de una distancia de corte , según la Ecuación . Esta enfoque permite
tener en cuenta el hecho de que las partículas pueden dejar de sentir
una fuerza de atracción cuando están muy separadas; así, las partículas
de fluido no están constreñidas en una estructura reticular como en la
ecuación , sino que son libres de fluir dentro del dominio.</p>
<figure>
<img src="imagenes/comparisonPotentials.png"
id="fig:comparisonpotentials"
alt="Poteciales de energy. Posicionamiento del potencial ármonico LSM ajustado con propósitos de ilustración." />
<figcaption aria-hidden="true">Poteciales de energy. Posicionamiento del
potencial ármonico LSM ajustado con propósitos de
ilustración.</figcaption>
</figure>
<figure>
<img src="imagenes/comparisonPotentialForces.png"
id="fig:comparisonPotentialForces"
alt="Campo de fuerza obtenido con los potenciales elástico, atractivo, repulsivo, y total." />
<figcaption aria-hidden="true">Campo de fuerza obtenido con los
potenciales elástico, atractivo, repulsivo, y total.</figcaption>
</figure>
<p>Para evitar la superposición de partículas, en nuestro modelo la
parte repulsiva se proporciona mediante otro potencial dado como, <span
class="math display">\[U_{\textrm{Soft}}(r) = \epsSoft \left[ 1 +
\cos{\left(\frac{\pi r}{ \rcSoft  }\right)} \right] \qquad r &lt;
\rcSoft\]</span> donde es la magnitud y es la distancia de corte para
este componente repulsivo del potencial adoptado, limitando así, una vez
más, la distancia a la que existe repulsión para partículas muy
alejadas. En el presente modelo propuesto utilizamos un potencial total
añadiendo estos componentes con el objetivo de imitar el comportamiento
elástico del modelo LSM, pero con la ventaja de que cuando la distancia
entre las dos partículas está por encima del valor de corte, la fuerza
se desactiva y la partícula es libre de fluir. En la se presenta una
ilustración de los potenciales LSM, repulsivo, atractivo y total,
mientras que en la se muestra una representación de las fuerzas
producidas por ellos, donde se representan esquemáticamente los
componentes repulsivo y atractivo de las fuerzas elásticas
equivalentes.</p>
<p>Dado que la lógica del modelo propuesto es poder obtener un
acoplamiento entre los dos estilos de pares que produzca una
repulsión/atracción estable dentro de un rango cercano de cada
partícula, este acoplamiento requiere una elección sensata de valores
dada la posible interacción compleja que puede producirse por el número
de parámetros en juego. Por ejemplo, una consideración importante,
normalmente crítica en otros métodos basados en mallas sólo desde la
perspectiva de la estabilidad numérica, es la resolución espacial. En
nuestro caso, la resolución espacial está vinculada de algún modo a la
distribución de las partículas, por lo que la estabilidad y eficacia del
modelo depende también de la malla empleada para la disposición inicial
de dichas partículas, así como de la longitud característica en la
malla, o escala de malla <span
class="math inline">\(\Delta_{L}\)</span>. Concretamente, con el fin de
reducir el número de parámetros libres, el potencial repulsivo se
definió en función de las características del potencial atractivo, de
modo que un único conjunto de valores pudiera definir por completo el
modelo acoplado elástico. Es importante mencionar que, dado que nuestro
modelo depende fuertemente del espaciado entre partículas, los datos
presentados a lo largo del presente trabajo como valores de referencia
deben tomarse como una guía para establecer simulaciones de trabajo, más
que como un rango restrictivo de condiciones de operación. En cualquier
caso, algunos rangos y definiciones empleados en la caracterización de
la componente elástica del presente modelo, determinados a través de
varios experimentos numéricos y que se ha comprobado que proporcionan
estabilidad numérica y consistencia con el comportamiento esperado, se
presentan en la a modo de referencia. En esta tabla los acrónimos BCC y
FCC significan Body-centred cubic (cúbica centrada en el cuerpo) y
Face-centred cubic (cúbica centrada en la cara), respectivamente, que
son algunos de los tipos más comunes de celdas regulares para
simulaciones de dinámica molecular.</p>
<div class="center">
<div id="tab:summaryElasticModel">
<table>
<caption>Resumen de algunos rangos y relaciones entre parámetros para el
potencial elástico.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: center;"><strong>BCC Lattice</strong></th>
<th style="text-align: center;"><strong>FCC Lattice</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Distancia de activación - potencial
atractivo</td>
<td style="text-align: center;"><span class="math inline">\(\sigma =
\sqrt{3}\,\Delta_{L}/2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\sigma =
\sqrt{2}\,\Delta_{L}/2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Distancia de corte - potencial
atractivo</td>
<td style="text-align: center;"><span
class="math inline">\(0.95\,\Delta_{L}\leq\rcCosSq\leq2.1\,\Delta_{L}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(0.9\,\Delta_{L}
\leq\rcCosSq\leq1.1\,\Delta_{L}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Distancia de corte - potencial
repulsivo</td>
<td style="text-align: center;"><span class="math inline">\(\rcSoft
\approx 1.05\,\rcCosSq\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(\rcSoft\approx 0.955\,\rcCosSq\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Prefactor - potencial repulsivo</td>
<td style="text-align: center;"><span
class="math inline">\(0.8\,\epsCosSq\leq\epsSoft\leq3.0\,\epsCosSq\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(1.25\,\epsCosSq\leq\epsSoft\leq4.0\,\epsCosSq\)</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Una vez definidos el tipo de estructura retícular a usar en la malla
inicial (BCC o FCC) y los valores de los paraámetros de los potenciales
atractivo y repulsivo del componente elástico, es necesario configurar
un script de caso de simulación LAMMPS. Existen muchas posibilidades de
estructura de tipo de archivo (<span class="citation"
data-cites="lammpsWeb"></span>). Un ejemplo de archivo de configuración
de caso LAMMPS para ser usado en simulación de flujos viscoelásticos
bajo el enfoque propuesto en este trabajo se presenta en el siguiente
código().</p>
<p>La definición de los parámetros a usar para la simulación de casos de
flujo viscoelástico mediante el enfoque DMP propuesto en el presente
trabajo se puede encontrar entre las líneas y del . El resto del
contenido del archivo de configuración es usado para definir geometría
(líneas a ), parámetros de ejecución (líneas a ), dominio y coondiciones
de frontera (líneas a ), propiedades de partícula (líneas a ) e
instrucciones de posprocesamiento y ejecución (líneas a )</p>

    </div>
	</section>
		<!-- Footer -->
			<footer id="footer">
				<div class="container">
					<ul class="icons">
						<li><a href="#" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
						<li><a href="#" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
						<li><a href="#" class="icon fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="#" class="icon fa-envelope-o"><span class="label">Email</span></a></li>
					</ul>
				</div>
				<div class="copyright">
					&copy; Untitled. All rights reserved. Coded <span>by caduqued@gmail.com</span>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
	</body>
</html>
